/* Mobile Maintenance Webform (DSIF-style)
   Template: maintenance_template.pdf
*/

const CONFIG = {
  "pageSize": {
    "w": 612,
    "h": 792
  },
  "tableRight": 570,
  "pages": [
    {
      "index": 0,
      "title": "Air Compressor \u2013 Daily Inspection Checklist",
      "items": [
        {
          "label": "Engine oil level correct",
          "y_center_top": 207.12000274658203
        },
        {
          "label": "Coolant level correct",
          "y_center_top": 225.12000274658203
        },
        {
          "label": "Fuel level sufficient",
          "y_center_top": 243.12000274658203
        },
        {
          "label": "No visible fluid leaks",
          "y_center_top": 261.1199951171875
        },
        {
          "label": "Air filters clean",
          "y_center_top": 279.1199951171875
        },
        {
          "label": "Moisture drained from system",
          "y_center_top": 297.1199951171875
        },
        {
          "label": "Hoses and fittings secure",
          "y_center_top": 315.1199951171875
        },
        {
          "label": "Guards and covers secure",
          "y_center_top": 333.1199951171875
        },
        {
          "label": "Gauges operating properly",
          "y_center_top": 351.1199951171875
        },
        {
          "label": "Emergency shutdown functional",
          "y_center_top": 369.1199951171875
        }
      ],
      "cols": {
        "ok_x": 309.2250061035156,
        "needs_x": 375.9835205078125,
        "comm_x0": 417.20001220703125,
        "table_right": 570
      },
      "project_blank": {
        "x0": 144.12998962402344,
        "y0": 159.25,
        "x1": 299.8099365234375,
        "y1": 172.99000549316406
      },
      "header_y_center_top": 188.79297637939453,
      "whiteout_top_y": 379.29998779296875,
      "whiteout_bottom_y": 780
    },
    {
      "index": 1,
      "title": "Dust Collector \u2013 Daily Inspection Checklist",
      "items": [
        {
          "label": "Guards and access panels secure",
          "y_center_top": 207.12000274658203
        },
        {
          "label": "Emergency stops functional",
          "y_center_top": 225.12000274658203
        },
        {
          "label": "Warning labels legible",
          "y_center_top": 243.12000274658203
        },
        {
          "label": "No visible damage or leaks",
          "y_center_top": 261.1199951171875
        },
        {
          "label": "Filter bags/cartridges intact",
          "y_center_top": 279.1199951171875
        },
        {
          "label": "Differential pressure normal",
          "y_center_top": 297.1199951171875
        },
        {
          "label": "Hopper free of buildup",
          "y_center_top": 315.1199951171875
        },
        {
          "label": "Dust discharge operating",
          "y_center_top": 333.1199951171875
        },
        {
          "label": "Control panel indicators normal",
          "y_center_top": 351.1199951171875
        },
        {
          "label": "No alarm conditions present",
          "y_center_top": 369.1199951171875
        }
      ],
      "cols": {
        "ok_x": 309.2250061035156,
        "needs_x": 375.9835205078125,
        "comm_x0": 417.20001220703125,
        "table_right": 570
      },
      "project_blank": {
        "x0": 144.12998962402344,
        "y0": 159.25,
        "x1": 299.8099365234375,
        "y1": 172.99000549316406
      },
      "header_y_center_top": 188.79297637939453,
      "whiteout_top_y": 379.29998779296875,
      "whiteout_bottom_y": 780
    },
    {
      "index": 2,
      "title": "Blast Machine \u2013 Daily Inspection Checklist",
      "items": [
        {
          "label": "Machine frame and guards intact",
          "y_center_top": 207.12000274658203
        },
        {
          "label": "Emergency stop functional",
          "y_center_top": 225.12000274658203
        },
        {
          "label": "Access doors secured",
          "y_center_top": 243.12000274658203
        },
        {
          "label": "Screens free of blockage",
          "y_center_top": 261.1199951171875
        },
        {
          "label": "Magnetic separator clean",
          "y_center_top": 279.1199951171875
        },
        {
          "label": "Conveyors operating smoothly",
          "y_center_top": 297.1199951171875
        },
        {
          "label": "Air lines free of leaks",
          "y_center_top": 315.1199951171875
        },
        {
          "label": "Bearings lubricated",
          "y_center_top": 333.1199951171875
        },
        {
          "label": "No abnormal vibration or noise",
          "y_center_top": 351.1199951171875
        }
      ],
      "cols": {
        "ok_x": 309.2250061035156,
        "needs_x": 375.9835205078125,
        "comm_x0": 417.20001220703125,
        "table_right": 570
      },
      "project_blank": {
        "x0": 144.12998962402344,
        "y0": 159.25,
        "x1": 299.8099365234375,
        "y1": 172.99000549316406
      },
      "header_y_center_top": 188.79297637939453,
      "whiteout_top_y": 361.29998779296875,
      "whiteout_bottom_y": 780
    },
    {
      "index": 3,
      "title": "Vacuum \u2013 Daily Inspection Checklist",
      "items": [
        {
          "label": "Blower operating normally (28\" Hg)",
          "y_center_top": 207.12000274658203
        },
        {
          "label": "Hoses free of damage",
          "y_center_top": 225.12000274658203
        },
        {
          "label": "Boom and joints operate smoothly",
          "y_center_top": 243.12000274658203
        },
        {
          "label": "Tank free of excessive buildup",
          "y_center_top": 261.1199951171875
        },
        {
          "label": "Rear door seals intact",
          "y_center_top": 279.1199951171875
        },
        {
          "label": "Door latching secure",
          "y_center_top": 297.1199951171875
        },
        {
          "label": "Sludge pump functional",
          "y_center_top": 315.1199951171875
        },
        {
          "label": "Valves operate smoothly",
          "y_center_top": 333.1199951171875
        },
        {
          "label": "No hydraulic leaks observed",
          "y_center_top": 351.1199951171875
        }
      ],
      "cols": {
        "ok_x": 309.2250061035156,
        "needs_x": 375.9835205078125,
        "comm_x0": 417.20001220703125,
        "table_right": 570
      },
      "project_blank": {
        "x0": 144.12998962402344,
        "y0": 159.25,
        "x1": 299.8099365234375,
        "y1": 172.99000549316406
      },
      "header_y_center_top": 188.79297637939453,
      "whiteout_top_y": 361.29998779296875,
      "whiteout_bottom_y": 780
    }
  ]
};

const state = {
  projectName: "",
  pages: CONFIG.pages.map(p => ({
    na: false,
    items: p.items.map(() => ({ status: "", comment: "" })),
    additionalComments: "",
    printName: "",
    date: "",
    location: "",
    signature: null, // dataURL (png)
    photos: [] // { dataURL, bytes(Uint8Array), desc }
  }))
};

const els = {
  pages: document.getElementById("pages"),
  projectName: document.getElementById("projectName"),
  sigModal: document.getElementById("sigModal"),
  sigCanvas: document.getElementById("sigCanvas"),
  sigTitle: document.getElementById("sigTitle"),
  sigClose: document.getElementById("sigClose"),
  sigClear: document.getElementById("sigClear"),
  sigCancel: document.getElementById("sigCancel"),
  sigSave: document.getElementById("sigSave"),
};

let sigActivePageIndex = null;
let sigDrawing = false;
let sigLast = null;

function todayISO() {
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${yyyy}-${mm}-${dd}`;
}

function isoToMMDDYYYY(iso) {
  if (!iso) return "";
  const m = iso.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return iso;
  return `${m[2]}/${m[3]}/${m[1]}`;
}

function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}

function dataURLToBytes(dataURL) {
  const parts = dataURL.split(',');
  const b64 = parts[1] || "";
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
  return bytes;
}

function setAllActionButtonsDisabled(disabled) {
  document.querySelectorAll('[data-action="reset"], [data-action="save"]').forEach(btn => {
    btn.disabled = disabled;
  });
}

function buildUI() {
  els.pages.innerHTML = "";

  CONFIG.pages.forEach((p, pageIndex) => {
    const card = document.createElement("section");
    card.className = "card";

    // Header
    const head = document.createElement("div");
    head.className = "section-head";

    const titleWrap = document.createElement("div");
    titleWrap.style.display = "flex";
    titleWrap.style.flexDirection = "column";
    titleWrap.style.gap = "2px";

    const title = document.createElement("div");
    title.className = "card-title";
    title.textContent = p.title;

    const metaLine = document.createElement("div");
    metaLine.className = "small";
    metaLine.textContent = `Checklist items: ${p.items.length}`;

    titleWrap.appendChild(title);
    titleWrap.appendChild(metaLine);

    const meta = document.createElement("div");
    meta.className = "section-meta";

    const badge = document.createElement("span");
    badge.className = "badge";
    badge.id = `photoBadge_${pageIndex}`;
    badge.textContent = "0 photos";

    const naWrap = document.createElement("label");
    naWrap.className = "na-wrap";
    naWrap.addEventListener("click", (e) => e.stopPropagation());

    const naCb = document.createElement("input");
    naCb.type = "checkbox";
    naCb.id = `na_${pageIndex}`;
    naCb.addEventListener("change", () => {
      state.pages[pageIndex].na = naCb.checked;
      renderPageState(pageIndex);
    });

    const naText = document.createElement("span");
    naText.textContent = "N/A";

    naWrap.appendChild(naCb);
    naWrap.appendChild(naText);

    meta.appendChild(badge);
    meta.appendChild(naWrap);

    head.appendChild(titleWrap);
    head.appendChild(meta);

    // Content collapsible
    const body = document.createElement("div");
    body.className = "collapse";
    body.id = `body_${pageIndex}`;

    head.addEventListener("click", () => {
      const isHidden = body.classList.contains("hidden");
      body.classList.toggle("hidden", !isHidden);
    });

    // Checklist items
    const checklist = document.createElement("div");
    checklist.className = "checklist";

    p.items.forEach((it, itemIndex) => {
      const item = document.createElement("div");
      item.className = "item";

      const itTitle = document.createElement("div");
      itTitle.className = "item-title";
      itTitle.textContent = it.label;

      const controls = document.createElement("div");
      controls.className = "item-controls";

      const okLabel = document.createElement("label");
      okLabel.className = "pill";
      const ok = document.createElement("input");
      ok.type = "radio";
      ok.name = `status_${pageIndex}_${itemIndex}`;
      ok.value = "ok";
      ok.addEventListener("change", () => {
        state.pages[pageIndex].items[itemIndex].status = "ok";
      });
      okLabel.appendChild(ok);
      okLabel.appendChild(document.createTextNode("OK"));

      const needsLabel = document.createElement("label");
      needsLabel.className = "pill";
      const needs = document.createElement("input");
      needs.type = "radio";
      needs.name = `status_${pageIndex}_${itemIndex}`;
      needs.value = "needs";
      needs.addEventListener("change", () => {
        state.pages[pageIndex].items[itemIndex].status = "needs";
      });
      needsLabel.appendChild(needs);
      needsLabel.appendChild(document.createTextNode("Needs Attention"));

      const clearLabel = document.createElement("button");
      clearLabel.className = "btn";
      clearLabel.type = "button";
      clearLabel.textContent = "Clear";
      clearLabel.addEventListener("click", () => {
        state.pages[pageIndex].items[itemIndex].status = "";
        document.querySelectorAll(`input[name="status_${pageIndex}_${itemIndex}"]`).forEach(r => r.checked = false);
      });

      controls.appendChild(okLabel);
      controls.appendChild(needsLabel);
      controls.appendChild(clearLabel);

      const cmt = document.createElement("textarea");
      cmt.className = "textarea";
      cmt.placeholder = "Comments (optional)";
      cmt.addEventListener("input", () => {
        state.pages[pageIndex].items[itemIndex].comment = cmt.value;
      });

      item.appendChild(itTitle);
      item.appendChild(controls);
      item.appendChild(cmt);
      checklist.appendChild(item);
    });

    body.appendChild(checklist);

    // Additional comments
    const addCard = document.createElement("div");
    addCard.className = "photos";
    addCard.innerHTML = `
      <div class="card-title" style="margin:0 0 8px 0;">Additional comments</div>
      <textarea id="add_${pageIndex}" class="textarea" placeholder="Additional comments for this equipment..."></textarea>
    `;
    body.appendChild(addCard);

    // Footer fields
    const footer = document.createElement("div");
    footer.className = "photos";
    footer.innerHTML = `
      <div class="card-title" style="margin:0 0 8px 0;">Operator</div>
      <div class="row">
        <label class="label">Printed name</label>
        <input id="pname_${pageIndex}" class="input" type="text" placeholder="Printed name"/>
      </div>
      <div class="row">
        <label class="label">Date</label>
        <input id="date_${pageIndex}" class="input" type="date"/>
      </div>
      <div class="signature-row">
        <div>
          <div class="small" style="margin-bottom:6px;">Signature</div>
          <div id="sigPreview_${pageIndex}" class="sig-preview" role="button" tabindex="0">Tap to sign</div>
        </div>
        <button id="sigClearBtn_${pageIndex}" class="btn" type="button">Clear signature</button>
      </div>
    `;
    body.appendChild(footer);

    // Photos
    const photos = document.createElement("div");
    photos.className = "photos";

    const attachId = `attach_${pageIndex}`;
    const inputId = `photoInput_${pageIndex}`;

    photos.innerHTML = `
      <div class="card-title" style="margin:0 0 8px 0;">Photos</div>
      <div class="small">Attach photos for this checklist. Each photo needs a brief description.</div>
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
        <button id="${attachId}" class="btn" type="button">Attach photos</button>
        <input id="${inputId}" type="file" accept="image/*" multiple style="display:none"/>
      </div>
      <div id="photoList_${pageIndex}" class="photo-list"></div>
    `;
    body.appendChild(photos);

    card.appendChild(head);
    card.appendChild(body);
    els.pages.appendChild(card);

    // Wire footer fields
    const addEl = document.getElementById(`add_${pageIndex}`);
    addEl.addEventListener("input", () => state.pages[pageIndex].additionalComments = addEl.value);

    const pnameEl = document.getElementById(`pname_${pageIndex}`);
    pnameEl.addEventListener("input", () => state.pages[pageIndex].printName = pnameEl.value);

    const dateEl = document.getElementById(`date_${pageIndex}`);
    dateEl.value = todayISO();
    state.pages[pageIndex].date = dateEl.value;
    dateEl.addEventListener("input", () => state.pages[pageIndex].date = dateEl.value);

    // Signature preview wiring
    const sigPreview = document.getElementById(`sigPreview_${pageIndex}`);
    sigPreview.addEventListener("click", () => openSignature(pageIndex, p.title));
    sigPreview.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") openSignature(pageIndex, p.title);
    });

    const sigClearBtn = document.getElementById(`sigClearBtn_${pageIndex}`);
    sigClearBtn.addEventListener("click", () => {
      state.pages[pageIndex].signature = null;
      renderSignaturePreview(pageIndex);
    });

    // Photo input wiring
    const attachBtn = document.getElementById(attachId);
    const fileInput = document.getElementById(inputId);
    attachBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", async () => {
      const files = Array.from(fileInput.files || []);
      fileInput.value = "";
      if (!files.length) return;
      for (const f of files) {
        try {
          const converted = await convertImageFileToJpegDataURL(f, 1600);
          state.pages[pageIndex].photos.push({
            dataURL: converted.dataURL,
            bytes: converted.bytes,
            desc: ""
          });
        } catch (err) {
          alert("Could not load one of the images. Try a different photo.");
        }
      }
      renderPhotos(pageIndex);
    });

    // initial render
    renderPageState(pageIndex);
  });
}

function renderPageState(pageIndex) {
  const pState = state.pages[pageIndex];
  const naCb = document.getElementById(`na_${pageIndex}`);
  const body = document.getElementById(`body_${pageIndex}`);

  if (naCb) naCb.checked = !!pState.na;

  // If N/A, collapse body (hide) but keep header visible
  if (pState.na) {
    body.classList.add("hidden");
  }

  // Disable inputs when N/A (but leave signature and photos disabled too)
  const card = body.closest(".card");
  const inputs = body.querySelectorAll("input, textarea, button");
  inputs.forEach(el => {
    // allow collapse toggle (not inside body), so okay
    el.disabled = pState.na;
  });

  renderSignaturePreview(pageIndex);
  renderPhotos(pageIndex);
}

function renderSignaturePreview(pageIndex) {
  const holder = document.getElementById(`sigPreview_${pageIndex}`);
  if (!holder) return;
  holder.innerHTML = "";

  const data = state.pages[pageIndex].signature;
  if (!data) {
    holder.textContent = "Tap to sign";
    return;
  }

  const c = document.createElement("canvas");
  c.width = 440;
  c.height = 128;
  holder.appendChild(c);

  const ctx = c.getContext("2d");
  const img = new Image();
  img.onload = () => {
    ctx.clearRect(0,0,c.width,c.height);
    // center fit
    const scale = Math.min(c.width/img.width, c.height/img.height);
    const w = img.width * scale;
    const h = img.height * scale;
    const x = (c.width - w)/2;
    const y = (c.height - h)/2;
    ctx.drawImage(img, x, y, w, h);
  };
  img.src = data;
}

function renderPhotos(pageIndex) {
  const list = document.getElementById(`photoList_${pageIndex}`);
  const badge = document.getElementById(`photoBadge_${pageIndex}`);
  if (!list || !badge) return;

  const photos = state.pages[pageIndex].photos;
  badge.textContent = `${photos.length} photo${photos.length===1?'':'s'}`;

  list.innerHTML = "";
  photos.forEach((ph, idx) => {
    const row = document.createElement("div");
    row.className = "photo-item";

    const img = document.createElement("img");
    img.className = "thumb";
    img.src = ph.dataURL;

    const fields = document.createElement("div");
    fields.className = "photo-fields";

    const desc = document.createElement("textarea");
    desc.className = "textarea";
    desc.style.minHeight = "56px";
    desc.placeholder = "Brief description of this photo (required)";
    desc.value = ph.desc || "";
    desc.addEventListener("input", () => ph.desc = desc.value);

    const meta = document.createElement("div");
    meta.className = "small";
    meta.textContent = `Photo ${idx+1}`;

    fields.appendChild(meta);
    fields.appendChild(desc);

    const rm = document.createElement("button");
    rm.className = "remove";
    rm.type = "button";
    rm.textContent = "Remove";
    rm.addEventListener("click", () => {
      state.pages[pageIndex].photos.splice(idx, 1);
      renderPhotos(pageIndex);
    });

    row.appendChild(img);
    row.appendChild(fields);
    row.appendChild(rm);

    list.appendChild(row);
  });
}

async function convertImageFileToJpegDataURL(file, maxDim=1600) {
  // Read file -> dataURL
  const dataURL = await new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(file);
  });

  const img = await new Promise((resolve, reject) => {
    const im = new Image();
    im.onload = () => resolve(im);
    im.onerror = () => reject(new Error("Image decode failed"));
    im.src = dataURL;
  });

  const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
  const w = Math.round(img.width * scale);
  const h = Math.round(img.height * scale);

  const canvas = document.createElement("canvas");
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,w,h);
  ctx.drawImage(img, 0,0,w,h);

  const outURL = canvas.toDataURL("image/jpeg", 0.85);
  const bytes = dataURLToBytes(outURL);
  return { dataURL: outURL, bytes };
}

function openSignature(pageIndex, title) {
  sigActivePageIndex = pageIndex;
  els.sigTitle.textContent = `Signature â€” ${title}`;
  els.sigModal.classList.remove("hidden");

  // Size canvas to modal width (HiDPI)
  requestAnimationFrame(() => {
    const canvas = els.sigCanvas;
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#111827";

    // Load existing signature if any
    const existing = state.pages[pageIndex].signature;
    if (existing) {
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0,0,rect.width,rect.height);
        ctx.drawImage(img, 0,0, rect.width, rect.height);
      };
      img.src = existing;
    } else {
      ctx.clearRect(0,0,rect.width,rect.height);
    }
  });
}

function closeSignature() {
  els.sigModal.classList.add("hidden");
  sigActivePageIndex = null;
  sigDrawing = false;
  sigLast = null;
}

function sigCanvasPos(evt) {
  const rect = els.sigCanvas.getBoundingClientRect();
  const x = (evt.clientX - rect.left);
  const y = (evt.clientY - rect.top);
  return {x, y};
}

function sigStart(evt) {
  evt.preventDefault();
  sigDrawing = true;
  sigLast = sigCanvasPos(evt);
}

function sigMove(evt) {
  if (!sigDrawing) return;
  evt.preventDefault();
  const ctx = els.sigCanvas.getContext("2d");
  const p = sigCanvasPos(evt);
  ctx.beginPath();
  ctx.moveTo(sigLast.x, sigLast.y);
  ctx.lineTo(p.x, p.y);
  ctx.stroke();
  sigLast = p;
}

function sigEnd(evt) {
  if (!sigDrawing) return;
  evt.preventDefault();
  sigDrawing = false;
  sigLast = null;
}

function sigClear() {
  const canvas = els.sigCanvas;
  const rect = canvas.getBoundingClientRect();
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,rect.width,rect.height);
}

function sigSave() {
  if (sigActivePageIndex == null) return;
  // Export as PNG dataURL
  const canvas = els.sigCanvas;
  // Downscale to a reasonable size for embedding
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = 880;
  exportCanvas.height = 260;
  const ctx = exportCanvas.getContext("2d");
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,exportCanvas.width, exportCanvas.height);

  const tmp = new Image();
  tmp.onload = () => {
    ctx.drawImage(tmp, 0,0, exportCanvas.width, exportCanvas.height);
    const dataURL = exportCanvas.toDataURL("image/png");
    state.pages[sigActivePageIndex].signature = dataURL;
    renderSignaturePreview(sigActivePageIndex);
    closeSignature();
  };
  tmp.src = canvas.toDataURL("image/png");
}

function ensureAllDatesDefaulted() {
  state.pages.forEach((p, idx) => {
    if (!p.date) p.date = todayISO();
    const el = document.getElementById(`date_${idx}`);
    if (el && !el.value) el.value = p.date;
  });
}

function resetAll() {
  if (!confirm("Reset all fields? This clears all checklists, comments, photos, and signatures.")) return;

  state.projectName = "";
  els.projectName.value = "";

  state.pages.forEach((p, i) => {
    p.na = false;
    p.items.forEach(it => { it.status=""; it.comment=""; });
    p.additionalComments = "";
    p.printName = "";
    p.date = todayISO();
    p.signature = null;
    p.photos = [];

    // Clear UI radios/comments
    document.querySelectorAll(`input[name^="status_${i}_"]`).forEach(r => r.checked = false);
    const addEl = document.getElementById(`add_${i}`);
    if (addEl) addEl.value = "";
    const pn = document.getElementById(`pname_${i}`);
    if (pn) pn.value = "";
    const dt = document.getElementById(`date_${i}`);
    if (dt) dt.value = p.date;

    const naEl = document.getElementById(`na_${i}`);
    if (naEl) naEl.checked = false;

    const body = document.getElementById(`body_${i}`);
    if (body) body.classList.remove("hidden");

    renderPageState(i);
  });
}

function wrapLines(text, maxWidth, font, size) {
  const words = (text || "").split(/\s+/).filter(Boolean);
  const lines = [];
  let line = "";

  for (const w of words) {
    const test = line ? line + " " + w : w;
    const width = font.widthOfTextAtSize(test, size);
    if (width <= maxWidth) {
      line = test;
    } else {
      if (line) lines.push(line);
      // very long word fallback
      if (font.widthOfTextAtSize(w, size) > maxWidth) {
        lines.push(w);
        line = "";
      } else {
        line = w;
      }
    }
  }
  if (line) lines.push(line);
  return lines;
}

async function savePDF() {
  ensureAllDatesDefaulted();

  // Require descriptions for attached photos
  for (let i=0;i<state.pages.length;i++) {
    const photos = state.pages[i].photos;
    for (let j=0;j<photos.length;j++) {
      if (!photos[j].desc || !photos[j].desc.trim()) {
        alert(`Please add a brief description for photo ${j+1} under "${CONFIG.pages[i].title}".`);
        return;
      }
    }
  }

  setAllActionButtonsDisabled(true);

  try {
    const templateBytes = await fetch("maintenance_template.pdf").then(r => r.arrayBuffer());
    const { PDFDocument, rgb, StandardFonts } = PDFLib;

    const pdfDoc = await PDFDocument.load(templateBytes);

    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    // Fill each checklist page
    for (let i=0;i<CONFIG.pages.length;i++) {
      const pageConf = CONFIG.pages[i];
      const page = pdfDoc.getPage(i);
      const { width, height } = page.getSize();

      const pState = state.pages[i];

      // Project name
      if (pageConf.project_blank && state.projectName) {
        const b = pageConf.project_blank;
        const yCenterTop = (b.y0 + b.y1) / 2;
        const x = b.x0 + 2;
        const y = height - yCenterTop - 5;
        const maxW = (b.x1 - b.x0) - 4;
        const size = 11;
        const lines = wrapLines(state.projectName, maxW, fontBold, size);
        page.drawText(lines[0] || "", { x, y, size, font: fontBold, color: rgb(0,0,0) });
      }

      // Column positions
      const okX = pageConf.cols.ok_x;
      const needsX = pageConf.cols.needs_x;
      const commX = pageConf.cols.comm_x0 + 2;
      const commW = (pageConf.cols.table_right - (pageConf.cols.comm_x0 + 4));
      const markSize = 12;

      const stampDate = isoToMMDDYYYY(pState.date || todayISO());
      const naText = `Not applicable for today ${stampDate}`;

      // Table rows
      for (let r=0;r<pageConf.items.length;r++) {
        const row = pageConf.items[r];
        const y = height - row.y_center_top;

        let status = pState.items[r]?.status || "";
        let comment = pState.items[r]?.comment || "";

        if (pState.na) {
          status = "";
          comment = naText;
        }

        if (status === "ok") {
          page.drawText("X", {
            x: okX - 4,
            y: y - 5,
            size: markSize,
            font: fontBold,
            color: rgb(0,0,0)
          });
        } else if (status === "needs") {
          page.drawText("X", {
            x: needsX - 4,
            y: y - 5,
            size: markSize,
            font: fontBold,
            color: rgb(0,0,0)
          });
        }

        if (comment) {
          const size = 9;
          const lines = wrapLines(comment, commW, font, size);
          page.drawText(lines[0] || "", {
            x: commX,
            y: y - 4,
            size,
            font,
            color: rgb(0,0,0)
          });
        }
      }

      // Remove photo blocks + original footer by whitening area
      const yTop = pageConf.whiteout_top_y;
      const yBot = pageConf.whiteout_bottom_y;
      const rectY = height - yBot;
      const rectH = yBot - yTop;

      page.drawRectangle({
        x: 42,
        y: rectY,
        width: 528,
        height: rectH,
        color: rgb(1,1,1),
        borderColor: rgb(1,1,1)
      });

      // Rebuild a clean bottom layout (still matches template style)
      const left = 78;
      const right = 534;
      const contentW = right - left;

      // Photos note
      const photoCount = pState.photos.length;
      const photoNote = photoCount ? `Photo attachments: ${photoCount} (see appended pages)` : "Photo attachments: none";
      page.drawText(photoNote, {
        x: left,
        y: rectY + rectH - 28,
        size: 10,
        font: fontBold,
        color: rgb(0,0,0)
      });

      // N/A badge
      if (pState.na) {
        page.drawText("N/A", {
          x: right - 28,
          y: rectY + rectH - 28,
          size: 10,
          font: fontBold,
          color: rgb(0,0,0)
        });
      }

      // Additional comments box
      page.drawText("Additional Comments:", {
        x: left,
        y: rectY + 250,
        size: 10,
        font: fontBold,
        color: rgb(0,0,0)
      });

      // Box
      page.drawRectangle({
        x: left,
        y: rectY + 150,
        width: contentW,
        height: 90,
        borderColor: rgb(0,0,0),
        borderWidth: 1
      });

      const addText = pState.na ? naText : (pState.additionalComments || "");
      if (addText) {
        const size = 10;
        const lines = wrapLines(addText, contentW - 10, font, size).slice(0,6);
        let y = rectY + 150 + 90 - 16;
        for (const ln of lines) {
          page.drawText(ln, {
            x: left + 5,
            y,
            size,
            font,
            color: rgb(0,0,0)
          });
          y -= 14;
        }
      }

      // Printed name + date
      const pnLabelY = rectY + 120;
      page.drawText("Printed Name:", { x:left, y: pnLabelY, size:10, font: fontBold, color: rgb(0,0,0) });
      page.drawText((pState.printName || ""), { x:left+88, y: pnLabelY, size:10, font, color: rgb(0,0,0) });

      page.drawText("Date:", { x:right-160, y: pnLabelY, size:10, font: fontBold, color: rgb(0,0,0) });
      page.drawText(stampDate, { x:right-120, y: pnLabelY, size:10, font, color: rgb(0,0,0) });

      // Signature
      page.drawText("Signature:", { x:left, y: rectY + 95, size:10, font: fontBold, color: rgb(0,0,0) });
      page.drawRectangle({
        x: left + 72,
        y: rectY + 62,
        width: contentW - 72,
        height: 38,
        borderColor: rgb(0,0,0),
        borderWidth: 1
      });

      if (pState.signature) {
        try {
          const sigBytes = dataURLToBytes(pState.signature);
          const sigImg = await pdfDoc.embedPng(sigBytes);
          const boxW = contentW - 72;
          const boxH = 38;
          const scale = Math.min(boxW / sigImg.width, boxH / sigImg.height);
          const w = sigImg.width * scale;
          const h = sigImg.height * scale;
          const x = left + 72 + (boxW - w)/2;
          const y = rectY + 62 + (boxH - h)/2;
          page.drawImage(sigImg, { x, y, width: w, height: h });
        } catch (e) {
          // ignore signature embed failures
        }
      }
    }

    // Append photo pages (one page per photo)
    for (let i=0;i<CONFIG.pages.length;i++) {
      const title = CONFIG.pages[i].title;
      const photos = state.pages[i].photos;

      for (let j=0;j<photos.length;j++) {
        const ph = photos[j];

        const p = pdfDoc.addPage([612, 792]);
        const { width, height } = p.getSize();

        p.drawText(title, {
          x: 72,
          y: height - 70,
          size: 16,
          font: fontBold,
          color: rgb(0,0,0)
        });

        p.drawText(`Photo ${j+1}`, {
          x: 72,
          y: height - 95,
          size: 11,
          font: fontBold,
          color: rgb(0,0,0)
        });

        const desc = ph.desc || "";
        if (desc) {
          const lines = wrapLines(desc, width - 144, font, 11).slice(0,4);
          let y = height - 118;
          for (const ln of lines) {
            p.drawText(ln, { x:72, y, size:11, font, color: rgb(0,0,0) });
            y -= 14;
          }
        }

        // Embed image
        try {
          const img = await pdfDoc.embedJpg(ph.bytes);
          const maxW = width - 144;
          const maxH = height - 220;
          const scale = Math.min(maxW / img.width, maxH / img.height);
          const w = img.width * scale;
          const h = img.height * scale;
          const x = (width - w)/2;
          const y = 80;
          p.drawRectangle({ x:72, y:72, width: width-144, height: height-220, borderColor: rgb(0.8,0.8,0.8), borderWidth: 1 });
          p.drawImage(img, { x, y, width: w, height: h });
        } catch (e) {
          p.drawText("Image could not be embedded.", { x:72, y: height/2, size:12, font, color: rgb(0.8,0,0) });
        }
      }
    }

    const outBytes = await pdfDoc.save();
    const blob = new Blob([outBytes], { type: "application/pdf" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    const stamp = isoToMMDDYYYY(todayISO()).replaceAll("/", "-");
    a.href = url;
    a.download = `JAGD_Maintenance_Checklists_${stamp}.pdf`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error(err);
    alert("Save failed. If you attached very large photos, try fewer/smaller photos and try again.");
  } finally {
    setAllActionButtonsDisabled(false);
  }
}

function wireGlobalActions() {
  // Sync project name
  els.projectName.addEventListener("input", () => {
    state.projectName = els.projectName.value;
  });

  // Action buttons (top + bottom)
  document.querySelectorAll('[data-action="reset"]').forEach(btn => {
    btn.addEventListener("click", resetAll);
  });
  document.querySelectorAll('[data-action="save"]').forEach(btn => {
    btn.addEventListener("click", savePDF);
  });

  // Signature modal events
  els.sigClose.addEventListener("click", closeSignature);
  els.sigCancel.addEventListener("click", closeSignature);
  els.sigClear.addEventListener("click", sigClear);
  els.sigSave.addEventListener("click", sigSave);
  els.sigModal.addEventListener("click", (e) => {
    if (e.target === els.sigModal) closeSignature();
  });

  // Draw events
  els.sigCanvas.addEventListener("pointerdown", sigStart);
  els.sigCanvas.addEventListener("pointermove", sigMove);
  window.addEventListener("pointerup", sigEnd);
}

(function init() {
  buildUI();
  wireGlobalActions();
})();
